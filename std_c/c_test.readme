DAY01 C语言基础知识
--------
--------------------------
1.C语言程序基本结构
2.C语言程序在Linux系统里的开发过程
3.变量
----------------------------------
1) C语言程序的绝大部分内容应该记录在以.作为扩展名的文件里，这种文件叫做C语言的源文件。 
接口实现文件C语言里还包括以.h作为扩展名的文件，这种文件叫头文件。

2) C语言程序里可以直接使用 数字 和 加减乘除四则运算符号(*代表乘法，/代表除法)
C语言程序里每个计算步骤最后都必须用分号做结尾

3) 每个用分号做结尾的计算步骤叫做一条语句 C语言程序里的绝大多数语句应该写在一对大括号中间
C语言程序里大括号可以用来代表函数（函数可以认为就是一组语句）每个函数都必须有名字，不同函数的名字不能
相同函数可以看作一组语句C语言程序里必须包含一个叫做main的函数，这个函数叫做主函数。

4) C程序一定从主函数里第一条语句开始执行，当主函数里最后一条语句结束后整个程序结束
函数可以用一个数字表示它的工作结果，这个数字叫做函数的返回值主函数应该有一个返回值，如果返回值是0表示
程序希望计算机认为它正常结束， 如果不是0表示程序希望计算机认为它出错了。

5) C语言程序里预先保留了几十个英文单词，它们叫做关键字。
每个关键字都有特定的用途，不能随便使用 所有关键字都是由小写英文字母构成的
return就是一个关键字，它有两个用途它的主要用途是结束函数的执行（总是起到这个作用）。
它的辅助用途是指定返回值的数值（如果关键字后有一个数字就把这个数字指定成返回值的数值）

6) C语言程序里预先保留了几十个英文单词，它们叫做关键字。
每个关键字都有特定的用途，不能随便使用 所有关键字都是由小写英文字母构成的。
return就是一个关键字，它有两个用途它的主要用途是结束函数的执行（总是起到这个作用）。
它的辅助用途是指定返回值的数值（如果关键字后有一个数字就把这个数字指定成返回值的数值）。

7) C语言程序编码规范
1.一行里最多包含一条语句
2.同级别的语句最左边一列应该上下对齐
3.在合适的地方使用空格和空行
C语言程序里通常包含预处理指令
预处理指令以#做开头，不是以;做结尾

8) 标准C阶段遇到的预处理指令都可以把文件里的内容替换成其他内容
#include预处理指令可以把一个头文件的内容包含到当前文件里
这个预处理指令中通常采用相对路径表示被包含头文件的位置
把相对路径包含在<>中间表示以系统中预先规定好的一组目录依次作为起点
把相对路径包含在""中间表示首先把当前文件 所在目录作为起点，然后再把系统中预先规定好的一组目录依次作为起点

9) C语言程序里可以加入文字性的说明信息 这些信息必须加入到注释区域里
计算机直接忽略注释区域里的内容 单行注释以//做开头一直到行尾 多行注释以/*做开头，以*/做结尾

10) C语言程序里大量使用名称区分不同内容
这些名称叫做标识符 标识符最好采用英文单词
标识符的编写规则
1.第一个字符可以是英文字母或下划线
2.后面的每个字符可以是英文字母，下划线
     或阿拉伯数字
3.大小写不同的标识符是不一样的(大小写敏感)
4.关键字不能作为标识符使用
5.标识符的长度没有限制，但是计算机只会
    截取前面一部分使用
6.标识符可以采用驼峰方式或下划线方式书写 

11) 编译器可以把编写好的文件翻译成计算机认识的格式
gcc是Linux系统里最常用的C语言编译器
MinGW是windows里的gcc

12) Linux系统里C语言程序开发基本过程
1.使用vi编写文件
2.使用gcc把所有文件翻译成可执行文件(编译)
3.使用./a.out作为命令执行得到的结果文件

13) gcc编译器的工作过程
1.处理所有预处理指令
2.把第一步的处理结果翻译成计算机认识
   的格式(编译)
3.把第二步的处理结果合并成最终的执行
    文件(链接)

gcc选项介绍
-E              只处理预处理指令
-c              只完成预处理和编译工作
                得到以.o作为扩展名的
                    目标文件
-o              用来指定结果文件名称
-std=c89/-std=c99
                指定采用什么版本的规则
                    进行编译
                默认采用c89规范编译

14) C语言里预先提供了一组工具，它们叫做标准函数
每个标准函数用来解决一个常见的问题不同标准函数的名称不同
可以在程序里编写函数调用语句使用标准函数
printf标准函数可以把程序里的数字显示在终端窗口里
为了使用这个标准函数需要包含stdio.h头文件
可以在双引号里使用占位符把数字转移到双引号后面双引号后面的数字可以是未知的（比如计算公式的结果）

15) 程序里使用的数字必须记录到内存里
计算机的内存由大量的字节构成的，每个字节可以单独记录一个数字.
每个字节有一个编号，不同字节的编号不同。
这个编号叫做字节的地址.所有字节的地址从0向正数方向递增.
字节地址有前后顺序，地址小的在前，地址大的在后.

16) 内存中几个相邻字节可以合并成一个整体用来记录一个数字. 可以把内存里用来记录一个数字的所有字节
叫做一个存储区一个存储区只能记录一种类型的数字存储区也有地址，这个地址就是存储区所包含的字节里最前面那个字节的地址.

17) C语言里用变量代表存储区,对变量的操作就是对存储区的操作.
变量需要先声明然后才能使用 变量声明语句用来声明变量,这种语句可以让 计算机为程序分配存储区.
可以在一条语句里声明多个同类型变量 变量只有两种使用小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中方法
一种是向变量里放一个数字,另外一种是从变量里获得一个数字。

18) 赋值语句可以向变量里放一个数字
赋值语句里用到了赋值操作符(=) 赋值操作符左边的内容必须可以代表一个存储区，这种内容叫左值(变量是一种左值)
赋值操作符右边的内容必须可以代表数字 赋值操作符可以把右边的数字放在左边的存储区里
可以在声明变量的时候立刻对变量进行赋值，这叫做变量的初始化
C语言里所有变量都应该初始化 可以在程序里直接把变量当作数字使用，这就是从变量里获得数字的办法
变量名称既可以代表存储区也可以代表存储区里的数字，由环境决定
当不能使用变量名称代表存储区的时候就可以 用存储区的地址代表存储区
在变量名称前使用符号&可以计算出存储区的地址 可以使用%p作为占位符把地址数据显示在屏幕上 变量可以用来代表固定数字
变量可以用来代表一组数字(变量可以在不同的时候代表不同的数字)



DAY02 数据类型
-------------------------------------------
1.数据类型
2.scanf标准函数
3.sizeof关键字
4.二进制
-------------------------------------------
1)
类型就是对数据的抽象
C 和 C++编译器用来表示人事物
数据类型包括 简单数据类型的对象
结构类型 指针类型 固定大小的数据内存
简单类型：
结构类型：
指针类型：
变量的本质就是内存区块的别名。

直接修改
间接修改（指针的方式）

名称 大小 作用域。
指针指向谁就把谁的地址赋给指针。
指针变量和指向的地址的变量不一样。

2) C操作系统怎么调用编程。操作系统把内存分成4个区。

操作系统的运行状态。

返回地址给 main函数的 运行状态 参数 返回地址嵌套调用。
main 的栈里面的 就会析构。
向null处拷贝数据 *就是一把钥匙 通过一个地址 去修改内存空间的值。
一级指针的本质作用就是利用调用空间传过来的存储区获得被存储区里面的值。
二级指针的本质就是利用调用空间床过来的存储区获得被调用函数里面的存储区的二级指针。
通过被调用函数修改调用函数的存储区的值和地址空间的值是一级指针和二级指针存在的重要意义。
间接赋值是指针存在的重要意义。由被调用函数里面去创建 分配 修改相关的变量。

3) char 占用1个字节 他是由8个位组成符类型里包含256个不同的整数， 
每个整数对应一个字符(例如'^','#'等) 这些整数和字符之间是一一对应的关系，
它们完全可以互相替代ASCII码表里列出所有整数和字符之间的对应关系。
'a'            97
'A'            65
'0'            48
所有字符数据被分成两组，每组包含128个其中一组字符对应的整数在所有计算机上
都一样，这些整数的范围从0到127 另外一组字符在不同计算机里对应的整数可能不同，
这些整数的范围可能从-128到-1也可能从128到255。

4) short 2个字节 16个位
-32818这个类型里包含65536个不同的整数，其中一半是负数另外一半是非负数.这些数字以0为中心向两边扩展

5) long && int 4个字节  32个位这个类型里包含2的32次方个不同的整数，其中
一半是负数另外一半是非负数。这些数字以0为中心向两边扩展。
整数类型名称是int 在我们的计算机里整数类型和长整数类型完全一样。
以上类型都叫做有符号类型每个有符号类型都有一个对应的无符号类型，
无符号类型的名称就是在对应有符号类型的名称前加unsigned关键字(例如unsigned int,unsigned char等)。

无符号类型包含的数字个数和对应的有符号类型一样，但是无符号类型里不包含负数。

6) float   f 4个字节  32个位
C语言里用浮点类型表示带小数点的数字 浮点类型分为单精度浮点类型和双精度浮点类型 双精度浮点类型可以记录更多小数点后面的数位。

7) double float lf 8个字节 程序里带小数点的数字默认是双精度浮点类型的

数据类型和占位符的对应关系
char 和 unsigned char            %c
short                           %hd
unsigned short                  %hu
long                            %ld
unsigned long                   %lu
int                             %d
unsigned int                    %u
float                           %f和%g
double                          %lf和%lg  

9) scanf
sizeof 关键字后面的小括号里可以写任何能当作数字使用的内容
sizeof 小括号里对任何存储区内容的修改不会真正发生
    
scanf标准函数可以在程序运行的时候从键盘得到用户输入的数字
为了使用这个标准函数需要包含stdio.h头文件
scanf函数调用语句里使用存储区的地址表示存储区
在双引号里使用占位符表示存储区的类型

一般不要在scanf函数调用语句的双引号里写不是占位符的内容
如果用户输入的格式和程序里希望的格式不同就无法获得数字
可以在一条scanf函数调用语句里得到多个数字    

一个字节分成八 每段只能记录一个0或者1 要想把一个数字记录到字节里就必须首先把这个数字拆分成八个0或者1

10) 进制
用一组0或者1表示数字的方式叫二进制 任何一个数字既可以采用十进制方式表示 也可以采用二进制方式表示
计算机里只能记录二进制方式表示的数字 二进制表示方式中每个数位有一个编号，最右边数位的编号是0向左依次递增如果某个数位的内容是1则它代表的数字
是2的数位编号次方。

11)二进制
二进制表示的非负数转换成十进制的时候
    只需要把所有数位里的1单独转换然后
    再求和就可以了。

0000 0101 = 2的2次方 + 2的0次方
          = 4 + 1
          = 5
          
0110 1011 = 2的6次方 + 2的5次方 + 2的3次方
               + 2的1次方 + 2的0次方
          = 64 + 32 + 8 + 2 + 1
          = 107

十进制表示的非负数转换成二进制的方法
12            *******0
 6            ******0
 3            *****1
 1            ****1
 0            ****

转换结果是0000 1100 

不停对数字进行除以2并保留整数部分的操作就
可以得到一组数字，用其中的每个数字除以2
取余可以得到一个数位的内容。最后把所有
数位的内容从后向前倒序书写就可以得到
转换结果

91        1
45        1
22        0
11        1
 5        1
 2        0
 1        1
 0        0

转换结果是0101 1011

12)八进制 0 

把二进制的所有数位从右向左每三个数位分成
   一组，每组用一个0到7之间的数字替代，
   得到的结果叫做数字的八进制表示方式
  
0110 1010     01 101 010      152(八进制)

可以直接在程序里用八进制方式表示数字，
    这种数字必须以0做开头
可以使用%o做占位符把数字的八进制表示方式
     显示在屏幕上
     
13)十六进制
     
把二进制所有数位从右向左每四个数位分成
    一组，每组用一个字符替换(用a到f之间
    的字符替代10到15之间的数字)。这个替换
    结果叫做数字的十六进制表示方式。

1100 1011        cb(十六进制)

可以在程序里用十六进制方式表示数字，这种
    数字必须以0x做开头
可以使用%x或%X做占位符把数字的十六进制
    表示方式显示在屏幕上
用%x做占位符的时候显示结果里所有字母都
    是小写的
用%X做占位符的时候显示结果里所有字母都是
    大写的
显示结果里不包含0x开头
————————————————

DAY 03 操作符
----------------------------------------
 操作符
----------------------------------------
1) 操作符代表对数字的处理规则

2) 根据操作符所需要配合的数字个数把操作符分为 单目操作符， 双目操作符 以及 三目操作符
加减乘除 (+, -, *, /) 四则运算符号 都是 双目操作符
如果参与除法计算的两个数字都是整数则计算结果只保留整数部分 C语言里用%表示取余 赋值操作符用 = 表示

3) 绝大多数双目操作符可以和赋值操作符合并形成复合赋值操作符， 例如 +=, /=等

复合赋值操作符也要求左边的内容必须代表存储区，右边的内容必须代表数字
复合赋值操作符可以把双目操作符的计算结果记录到左边的存储区里
复合赋值操作符的优先级和赋值操作符的优先级一样低

4) ++ --
自增操作符(++)和自减操作符(--)都是单目操作符
它们都必须和存储区配合使用，它们可以把存储区的内容加一或减一
它们各有两种使用方法，一种是前操作(把操作符写在存储区的前面)，另外一种是后操作(把操作符写在存储区后面)
用自增或自减操作符编写的表达式本身可以当作数字使用，前操作当数字使用的时候是修改后的数字，后操作当数字使用的时候是修改
前的数字 不要在一条语句里对同一个变量多次进行自增或自减计算，因为结果不确定

逻辑表达式的结果只能是布尔值 逻辑操作符用来编写逻辑表达式

5)!是一个单目逻辑操作符，它表示对一个布尔值求反(真变假，假变真)
这个操作符使用的时候要写在一个布尔值的前面

双目逻辑操作符包括 ==(等于), !=(不等于),  >(大于), <(小于), >=(大于等于) 和 <=(小于等于)
最多包含一个双目逻辑操作符的表达式叫简单逻辑表达式，它在数学里的结果和在计算机里的结果一定一样。

可以使用与(&&)和或(||)合并两个逻辑表达式 如果两个逻辑表达式里有一个的结果是假，用与(&&)合并以后结果也一定是假
如果两个逻辑表达式里有一个的结果是真，用或(||)合并以后结果也一定是真

与(&&)和或(||)都具有短路特征(如果前面逻辑表达式的结果可以决定整个逻辑表达式的结果则忽略后面的逻辑表达式

6)位操作符用来操作二进制数位的内容
~是一个单目位操作符
它可以根据一个数字计算出另外一个数字，这
    两个数字所有二进制数位的内容都不一样
    (按位求反)
双目位操作符包括按位与(&),按位或(|)和
    按位异或(^)
它们都可以把两个数字对应二进制数位的
    内容做计算
————————————————
按位与(&)可以把对应数位的内容做与计算
只要一个数位内容是0则与计算以后结果就是0

任何数位内容和0做按位与结果一定是0
任何数位内容和1做按位与结果保持不变
可以使用按位与单独获得一个数字里
    某些二进制数位的内容

    7)
>>表示向右移位操作
<<表示向左移位操作

它们都是双目位操作符
操作符左边的数字是将要进行移位操作的数字
操作符右边的数字是移动的位数
移位操作相当于把每个数位的内容放到另外
    一个数位里
    
    向左移位的时候右边空出来的位置里一定填充0
有符号类型数字右移的时候左边空出来的数位
    里一定填充符号位的内容，无符号类型数字
    右移的时候左边空出来的数位里一定填充0
    
    
一般情况下向左移动n个位置相当于乘以2的n次方，
    向右移动n个位置相当于除以2的n次方
    *也可以作为单目操作符使用
这个时候它可以根据一个地址找到地址对应
    的存储区
这个操作符使用的时候应该写在一个地址
    数据前面

8)三目操作符

三目操作符可以从两套计算规则里选择一套进行计算
三目操作符格式如下
布尔值 ? 公式一 ： 公式二
如果布尔值为真就采用公式一进行计算，否则采用公式二进行计算
不要在三目表达式的问号后使用赋值操作符 

9) 如果表达式里包含多个不同类型的数字计算机 就必须首先把它们转换成同一个类型然后 才能计算。
这个转换过程叫隐式类型转换，完全由计算机完成。

10)如果表达式里包含多个不同类型的数字计算机
    就必须首先把它们转换成同一个类型然后
    才能计算。
这个转换过程叫隐式类型转换，完全由计算机
    完成。
    
隐式类型转换过程中一定把占地小的类型转换
    成占地大的类型。

如果不同类型存储区的大小一样就把整数类型
   转换成浮点类型，把有符号类型转换成
   无符号类型。

11)C语言程序里可以临时给数字指定一个类型，
    这叫做强制类型转换
强制类型转换格式如下
(char)300
强制类型转换有可能造成数据内容丢失
类型转换不会修改存储区内容。

DAY 04 流程控制语句
-------------------------------------
1.while
2.do while 
3.for 
-------------------------------------
1. if 复杂判断 简单循环
switch 适合简单判断 多重循环
if else  switch case 

2.while for
for();
while();
do{} while();

3.break continue

4. 使用以下两条固定语句把输入缓冲区里第一个
   '\n'字符前面的内容和这个'\n'字符一起
   从输入缓冲区里删除
scanf("%*[^\n]");
scanf("%*c");

printf函数把数字放在输出缓冲区里，然后
    计算机把输出缓冲区里的数字显示在
    屏幕上在以下四种情况下输出缓冲区里的内容会
    显示在屏幕上
1.如果输出缓冲区里包含'\n'字符则这个字符
     前面的所有内容会显示在屏幕上
2.程序结束后输出缓冲区里的内容会显示在
     屏幕上
3.当输出缓冲区被充满的时候它里面的内容
      会显示在屏幕上
4.可以使用fflush(stdout);语句强制把输出
      缓冲区里的内容显示在屏幕上

数组可以用来代表内存里一组连续的同类型
    存储。

DAY 05 函数
----------------------------------------
    1.二维数组练习

    2.函数
----------------------------------------
1) C语言可以把程序里的语句分组
每组叫做一个函数
多函数程序执行的时候时间分配情况必须符合
    以下规则

2)1.整个程序的执行时间被分成几段，不同时间
    段被分配给不同函数使用
2.所有时间段之间不能互相重叠而且必须连续
3.如果函数A把自己的时间分配给函数B使用
    则它们之间存在函数调用关系，函数B在
    完成工作之后必须把时间再还给函数A
函数调用过程中先获得时间的函数叫调用函数，
   后获得时间的函数叫被调用函数
————————————————

函数调用关系在被调用函数存在期间有效
函数调用语句可以在函数之间产生函数调用关系
不可以跨函数使用变量
不同函数里的变量可以重名
如果函数会多次执行则每次执行的时候里面的变量代表的存储区都可能不同
可以使用volatile关键字声明变量，这种变量里的内容可以被其他程序修改
————————————————

函数调用过程中通常伴随着两个函数之间的数据传递
函数调用过程中存在两个完全相反的数据传递方向，可以从调用函数向被调用
函数传递数据也可以从被调用函数向调用函数传递数据

无论哪个方向的数据传递都需要使用被调用函数提供的存储区实现

3)只能在被调用函数结束的时候才能向调用函数传递返回值
返回值必须记录在被调用函数提供的一个存储区里，这个存储区的类型名称要写在函数名称前
被调用函数里使用return关键字把返回值放在专用的存储区里
把函数调用语句当作数字使用就可以得到函数的返回值

5)如果被调用函数没有使用return关键字把返回值放在专用存储区里则这个存储区里的内容是
随机的调用函数只有一次获得返回值的机会，得到以后或者立刻使用或者存储在存储区里
函数名称前写void表示函数不提供存放返回值的存储区
函数名称前什么都没写在C89规范里表示函数
提供一个整数类型存储区用来存放返回值，在C99规范里不允许这样
被调用函数不可以使用数组存放返回值

6) 可以从调用函数向被调用函数传递任意多个数字，这些数字的类型可以不同
被调用函数需要为每个数据提供一个对应的存储区
需要在函数名称后的小括号里声明一组变量，这些变量用来代表这些存储区
这些 变量叫做函数的形式参数，小括号里的所有内容叫做函数的形式参数列表
每个形式参数的类型名称都不可以省略
相邻形式参数声明之间用逗号分开
被调用函数里可以象使用普通变量一样使用形式参数
调用带有形式参数的函数时需要在函数调用语句的小括号里为每个形式参数提供一个
对应的数字。计算机把这些数字记录到对应的形式参数里，被调用函数可以通过
形式参数得到这些数字。

7) 如果编译器在编译的时候首先遇到函数调用 语句就会猜测函数的格式。计算机认为函数提供一个整数类型的存储区用来记录
   返回值，函数有任意多个不确定类型的形式参数。这个猜测结果叫做函数的隐式声明 隐式声明里形式参数的类型只能是int或double类型。

DAY 06 变量
-----------------------------------
    1.局部变量和全局变量
    2.生命周期和作用域
-----------------------------------
1) 能够使用某个变量的所有语句叫做这个变量
    的作用域78

声明在函数里面的变量叫做局部变量，局部变量的作用域包含函数里面的所有语句
声明在所有函数外边的变量叫做全局变量，全局变量的作用域包含程序里的所有语句
没有初始化的全局变量自动被初始化成0
全局变量可以和局部变量重名，这个时候变量
     名称优先代表局部变量

2) 如果 全局变量 和 局部变量 都能解决问题就优先
选择采用局部变量
存储区的使用不受作用域的限制(可以跨函数使用存储区)
存储区的使用受到生命周期的限制
生命周期指一段时间，在时间开始的时间计算机
把存储区分配给程序，在时间结束的时候计算机把存储区收回
全局变量的生命周期是整个程序的执行时间
局部变量的生命周期是函数某一次执行的时间范围
————————————————

3) char当函数开始执行的时候计算机为局部变量分配
存储区，当函数结束的时候计算机把局部变量的存储区收回
如果函数多次执行则每次执行的时候局部变量被分配的存储区都可能不同
静态变量的生命周期和作用域跟普通变量不一样
声明静态变量的时候需要使用static关键字
不论全局变量还是局部变量都可以声明成静态变量
静态局部变量的生命周期是整个程序的执行时间
没有初始化的静态变量会自动被初始化成0
静态局部变量的存储区随时可以使用
静态局部变量的作用域和普通局部变量的作用域一样
————————————————
4) 静态局部变量的初始化只在程序开始的时候执行一次
静态全局变量的生命周期不变，但是作用域 只包含声明它的文件里的所有语句(不可以跨文件使用静态全局变量)

5) 变量的作用域分为三种情况：局部变量，静态全局变量和非静态全局变量
变量的生命周期分为两种情况：非静态局部变量和其它。

DAY 07     指针
---------------------------------------
指针
---------------------------------------
指针变量只能记录地址数据
指针变量的用途就是用来找到一个普通类型的存储区
只有记录有效地址的指针才能用来找到普通类型的存储区
声明指针变量的时候需要在变量名称前加*如果一个指针记录了一个存储区的地址则它们之间存在捆绑关系

如果一个指针变量和一个存储区之间存在捆绑关系就可以在指针变量名称前使用*操作符
表示它捆绑的存储区   *****声明指针变量时候的类型名称表示指针适合与什么类型的存储区捆绑
可以在一条语句里声明多个同类型的指针变量，这个时候需要在每个指针变量名称前单独加*

程序里禁止出现野指针所有指针变量必须进行初始化
指针初始化的时候*没有参与赋值过程

指针和存储区的捆绑关系可以随着程序的执行不断改变
指针可以看作它捆绑存储区的某种特征或身份

用指针和数组里第一个存储区捆绑后就可以通过指针找到数组里的每个存储区
指针后直接使用下标就可以表示数组里的存储区
地址数据可以进行以下三种计算
地址 + 整数    地址 - 整数   地址 - 地址
地址数据加减整数n实际上加减的是n个捆绑存储区的大小
数组里第一个存储区的地址加下标可以得到下标对应存储区的地址
可以采用如下方法表示数组里的存储区
*(arr + num)
其中arr是数组名称，代表数组里第一个存储区的地址，num是下标
地址减地址的结果是两个地址之间包含的捆绑存储区个数
————————————————

声明指针变量的时候可以使用const关键字
如果声明指针变量的时候把const关键字写在类型名称前就表示不可以通过这个指针
对它捆绑的存储区做赋值，但是可以对指针本身做赋值

如果声明指针变量的时候把const关键字写在
    变量名称前就表示可以通过这个指针对
    它捆绑的存储区做赋值，但是不可以对
    指针本身做赋值
可以在声明指针变量的时候使用void作为类型名称
可以把这种指针叫做无类型指针
这种指针可以和任意类型存储区捆绑
无法通过这种指针知道捆绑存储区的类型
不应该在无类型指针前直接加*操作符也
    不应该直接对无类型指针进行加减整数
    的计算
这种指针必须首先强制类型转换成有类型指针
    然后才能使用
所有跨函数使用存储区都是通过指针实现的
数组做形式参数的时候真正的形式参数其实
    是一个指针
声明指针类型形式参数的时候尽量使用const
   关键字
无类型指针通常作为形式参数使用    .
————————————————

DAY 08 字符串
------------------------------------
字符串
------------------------------------

1)所有文字信息必须以'\0'字符作为结尾，这个
    字符的ASCII码就是数字0
符合以上两个特征的内容就可以在C语言程序里
    代表文字信息，它们叫做字符串
字符串里'\0'字符前面的部分才是有效的
所有字符串都可以用字符类型指针表示
字符串字面值是一种字符串，用一对双引号
    中间的一组字符表示，例如"abc","^*(&"等
编译器在编译的时候会自动在字符串字面值末尾
    加上'\0'字符

2)编译器会把字符串字面值替换成第一个字符
    类型存储区的地址
字符串字面值的内容在程序执行过程中不可以
    改变
程序中多个内容一样的字符串字面值其实是
    同一个
多个并列的字符串字面值会被合并成一个
字符数组也可以用来表示字符串
只有包含'\0'字符的字符数组才可以当作
    字符串使用
可以使用字符串字面值对字符数组进行初始化，
    字符串字面值最后的'\0'字符也会被
    初始化到字符数组里去
字符数组里字符串的内容可以修改

strlen       统计字符串里有效字符的个数
             和sizeof结果不同
strcat       合并两个字符串的内容 
             第一个参数必须是字符数组
             如果合并后的字符串超过数组
                的长度就会修改不属于数组
                的存储区，这可能造成严重错误
                strncat      功能和strcat类似，但是可以避免
                出问题
strcmp       用来比较两个字符串的大小
             返回值为1表示前一个字符串大
             返回值为-1表示后一个字符串大
             返回值为0表示一样大
strncmp      功能和strcmp类似，可以只比较
             两个字符串里的前n个字符
strcpy       可以把一个字符串复制到字符数组
                里
             如果字符串超过字符数组的长度
                就会修改不属于数组的存储区，
                这会造成严重错误
strncpy      功能和strcpy类似，但是可以只
                复制前n个字符
             复制内容里可能不包含'\0'字符
memset       可以把字符数组里多个字符类型
                存储区的内容设置成同一个
                字符
————————————————

DAY09 .宏
#define预处理指令可以用来定义宏
宏可以用来给数字起名字
定义宏的时候要把宏名称写在前面，把它所代表的数字写在后面
宏名称通常都是由大写字母构成的
宏名称里不可以包含空格
用宏给数字起名字的时候不要使用赋值操作符
可以在程序里用宏名称代表数字，编译器会把程序里的所有宏名称替换成它所代表
的数字可以在编译命令里使用-D选项指定宏所代表的数字
如果程序里的一些数字只有在编译的时候才能
确定就可以在编写的时候用宏代表它们
宏还可以用来给一个计算公式起名字
计算公式里需要包含未知数字，宏的参数
可以用来表示这些未知数字
编译器采用二次替换的方式处理带参数的宏
宏的参数不一定代表数字，所以没有类型名称
如果宏有多个参数就需要在相邻的参数之间用逗号分隔开
宏不可以使用自己的存储区和函数之间进行数据传递
宏没有形式参数也没有用来记录返回值的存储区
能当作数字使用的宏必须编写成一个表达式
(宏没有用来存放返回值的存储区)
宏的参数可以直接代表函数的存储区，修改宏参数的内容就是修改函数存储区的内容
    
因为宏没有用来记录返回值的存储区，所以不能保证优先计算宏里面的操作符
    
所有能当作数字使用的宏必须写在小括号里面
宏没有形式参数所以不能保证优先计算参数里面的操作符

编写宏的时候必须把所有能当作数字使用的参数都写在小括号里
不要把自增或自减的结果作为参数使用宏
编写宏的时候可以使用一些特殊的符号，它们叫做宏操作符
   
#是一个宏操作符，它可以把宏的参数转换成字符串字面值
##也是一个宏操作符，它可以把一个代表 标识符的宏参数和其他内容连接得到
一个新的标识符 以上结构可以根据一个宏名称是否被定义过
从两组语句里选择一组编译而忽略另外一组 最开始的预处理指令应该从两个里选择一个，
不论选择哪个都应该在后面跟着一个宏名称
如果最开始选择#ifdef则它后面的宏名称被定义过就编译前一组语句，否则编译后
一组语句 如果最开始选择#ifndef就和#ifdef刚好相反.
————————————————
DAY10 多文件编程。
---------------------------------------------------------
    1.条件编译
    2.多文件编程
    3.结构体
---------------------------------------------------------
#if...#elif(任意多个)...#else...#endif
这个结构也可以实现条件编译，它可以根据任意
    逻辑表达式从多组语句中选择一组编译
    而忽略其它组
#if和#elif后面都需要跟着逻辑表达式，这些
    逻辑表达式里可以使用任何逻辑操作符，
    它们的作用和在if分支里的作用一样

多文件编程的时候一个文件里可以包含多个函数，
    一个函数只能属于一个文件
——— 多文件编程基本步骤
1.把所有函数分散在多个源文件里
   (主函数通常单独占一个文件)
2.为每个源文件编写配对的头文件
    (主函数所在的文件不需要配对头文件)
    所有不分配内存的内容都可以写在
    头文件里，头文件里至少要包含配对
    源文件里所有函数的声明语句。
3.在每个源文件里使用#include预处理指令
    包含必要的头文件(配对头文件是必要
    头文件，如果源文件使用了某个头文件里
    声明的函数则这个头文件也是必要头文件)
可以在gcc命令后把所有源文件的路径都列出来，
  这样的命令可以编译多文件方式编写的
    程序
————————————————
也可以采用Makefile文件编译多文件编写的程序
Makefile文件里可以记录整个程序的编译步骤，
    然后使用make工具根据Makefile文件里记录
    的步骤进行编译

头文件内容应该包含在条件编译的预处理指令中，
这样可以避免多次编译
第一个预处理指令必须是#ifndef
头文件里使用的宏名称应该根据文件名变化得到

如果想在一个源文件里使用另外一个源文件里声明的全局变量就必须使用extern关键字
再次声明这个全局变量
   
使用extern关键字声明变量的语句不会分配内存，所以通常放在头文件里

不可以跨文件使用静态全局变量

C语言里可以在一个存储区里记录多个相关数字
这种存储区的类型叫结构体类型
结构体类型需要先创建然后才能使用
结构体存储区里包含多个子存储区，每个子
    存储区可以用来记录一个数字
结构体存储区里不同子存储区的类型可以不同，
    甚至子存储区的类型也可以是结构体类型
结构体声明语句可以用来创建结构体类型
声明结构体的时候需要使用struct关键字
结构体声明语句里包含多个变量声明语句，
    这些变量叫做结构体的成员变量，每个
    成员变量代表一个子存储区
成员变量声明语句不会分配存储区，它们只是
    代表子存储区的类型和名称
C语言的结构体不可以包含函数
结构体声明语句可以写在任何地方(包括头文件里)
可以把结构体作为类型声明变量，这种变量
    叫做结构体变量
把结构体作为类型使用的时候需要把struct
   关键字和结构体名称一起作为类型名称使用
结构体变量被分配了内存，可以用来存放数字

typedef关键字可以用来给一个数据类型起别名
别名可以代替原来的类型名称使用
通常会给结构体类型起别名

可以把结构体声明语句和起别名语句合并成一条
    语句
这个时候可以省略结构体本身的名称

声明结构体变量的时候可以进行初始化，
    初始化方法和数组初始化方法一样
    
    结构体变量通常不会作为整体使用，一般一次
   只使用其中的某个子存储区
可以使用如下写法表示结构体变量的子存储区
prsn.age
其中prsn是一个结构体变量的名称，age是
   一个成员变量的名称
   
   同类型结构体变量之间可以直接赋值
   
   同类型结构体变量之间可以直接赋值

结构体指针可以用来记录一个结构体存储区
    的地址
以下写法可以通过结构体指针表示结构体
    的子存储区
p_person->age
其中p_person是一个结构体指针，age是一个
成员变量
可以使用结构体类型的形式参数从调用函数
向被调用函数传递结构体数据
直接使用结构体类型的形式参数会造成时间和空间的浪费
使用结构体指针类型的形式参数可以避免这种浪费
声明结构体指针类型的形式参数时尽量使用const关键字
可以把整个结构体数据当作返回值使用
这个时候就要求被调用函数提供一个结构体类型的存储区用来存放这个返回值
这也会造成时间和空间的浪费
使用结构体存储区的地址作为返回值可以避免这种浪费(这个时候就要求被调用函数提供
————————————————
一个存储区的地址必须是它自身大小的整数倍
(double类型存储区的地址只需要是4的整数倍)
这个规则叫做数据对齐
结构体的子存储区通常也需要遵守数据对齐的规则
数据对齐可能导致结构体子存储区之间有空隙

结构体存储区的大小必须是它所包含的占地最大的基本类型子存储区大小的整数倍(如果这个子存储区是double类型则结构体存储区的大小只需要是4的整数倍)这个规则叫数据补齐
数据补齐可能导致结构体最后有一些浪费的字节

枚举也可以用来创建数据类型
枚举类型存储区就是整数类型存储区，但是这种类型存储区里应该只用来记录有限
的几个整数
枚举类型也需要先声明然后才能使用
声明枚举类型时需要使用enum的关键字
声明枚举类型的时候还需要提供一组名称， 计算机为每个名称分配一个对应的整数，只有这些整数可以记录在这种枚举类型的存储区里
不同枚举类型存储区所能记录的数字范围不同 计算机为枚举类型里第一个名称分配的整数是0，向后依次递增
可以在声明枚举类型的时候指定某个名称对应的整数，这个时候后面名称对应的整数也会随着变化
————————————————
联合也可以用来创建数据类型
联合也需要先声明然后才能使用
声明联合的时候需要使用union关键字
联合里所有子存储区所占的位置互相重叠，它们的开始地址一样
联合存储区的大小是最大成员变量的大小
联合存储区可以当作多种不同类型存储区使用，
每个成员变量代表了一种可选的类型
————————————————

DAY11 内存分配 文件IO
可以在程序运行的时候临时决定需要分配多少
    个存储区
这种分配存储区的方法叫动态内存分配
为了管理动态分配内存需要使用一组标准函数
为了使用这些标准函数需要包含stdlib.h头文件

malloc 函数可以动态分配一组连续的字节
这个函数需要一个整数表示希望分配的字节个数
这个函数的返回值表示分配好的第一个字节的地址
如果分配失败则返回值是NULL
这个函数把返回值记录在无类型指针里,使用前需要进行强制类型转换

计算机不会主动回收动态分配的存储区
当程序不再使用动态分配内存后需要主动 把它们还给计算机(这叫做释放内存)
free函数可以用来释放动态分配内存 一起分配的内存必须一起释放
这个函数需要第一个字节的地址作为参数 如果使用指针做参数调用free函数就必须在 函数结束后把指针恢复成空指针
————————————————

调用函数可以使用被调用函数动态分配的存储区
calloc函数也可以动态分配连续的存储区
为了使用这个函数也需要包含stdlib.h头文件
这个函数可以把动态分配的所有存储区内容都设置成0
这个函数的返回值就是分配好的第一个字节的地址
这个函数也可能会失败，如果失败返回值也是NULL

realloc函数可以调整一段动态分配内存里的
   存储区个数
尽量少使用

所有文件都采用二进制方式记录内容
如果文件里的所有二进制数据都对应字符
    就把这种文件叫做文本文件
文本文件以外的文件都叫做二进制文件
C语言里提供了两种操作文件的方法，一种方法
   只能操作文本文件(以文本方式操作文件)，
   另外一种方法可以操作所有文件(以二进制
    方式操作文件)
    文件操作基本步骤
1.打开文件(fopen)
2.操作文件(fread/fwrite)
3.关闭文件(fclose)

fopen函数用来打开文件，它需要两个参数 第一个参数表示要打开文件的路径 第二个参数表示打开文件的方式(决定程序里可以对文件做什么操作)
打开方式有如下选择
"r"        只能察看文件内容不能修改
           只能从文件头开始察看
           如果文件不存在打开会失败
"r+"       比"r"多了修改文件内容的功能
"w"        只能修改文件内容不能察看
           只能从文件头开始修改
           如果文件不存在就创建文件
           如果文件存在就删除里面的所有内容
"w+"       比"w"多了察看文件内容的功能
"a"        只能修改不能察看
           只能在原有内容后追加新内容
           如果文件不存在就创建文件
           如果文件存在不会修改文件原有内容
"a+"       比"a"多了察看文件内容的功能

"b"也是一种打开方式
它可以和上面任何一种打开方式混合使用
如果在程序里使用二进制方式操作文件就应该在
    打开方式里加上这个"b"
————————————————
fopen函数的返回值是一个地址，应该记录在
    文件指针里。程序里只能用文件指针表示
    打开的文件。

fopen函数有可能失败，如果失败则返回值是NULL
完成对文件的所有操作之后必须用fclose函数关闭文件
fclose函数需要文件指针作为参数文件关闭后文件指针成为野指针，必须恢复成空指针
文件操作分为两种 

把内存里一组连续存储区的内容拷贝到文件里(写文件)
把文件里一组连续存储区的内容拷贝到内存里(读文件)

fread函数以二进制方式对文件进行读操作
fwrite函数以二进制方式对文件进行写操作

这两个函数都需要四个参数
第一个参数表示内存里第一个存储区的地址
内存里单个存储区的大小
希望操作的存储区个数
文件指针

这两个函数的返回值都表示实际操作的存储区个数

以下两个函数以文本方式操作文件

fpirntf函数可以把数据按照指定的格式记录到文本文件里
这个函数的第一个参数是一个文件指针，后面的参数就是printf函数的参数.

fscanf函数可以按照格式从文本文件里获得数字并记录到存储区里
这个函数的第一个参数是文件指针，后面的参数就是scanf函数的参数

这两个函数只适合操作数据量比较少的文件
计算机里为每个打开的文件保留了一个整数，
这个整数表示下一次读写操作的开始位置
这个位置一定在两个相邻的字节之间
这个整数记录文件头到这个位置之间包含的字节个数
这个整数叫做文件的位置指针
每当从文件里获得n个字节或写入n个字节之后位置指针会向后移动n个字节
ftell函数可以获得位置指针的数值

rewind函数可以把位置指针的数值设置成0

fseek函数可以把位置指针移动到文件里的任何位置
fseek函数里需要提供一个基准位置以及目标位置到基准位置之间的距离

SEEK_SET     0     把文件头作为基准位置
SEEK_CUR     1     把当前位置作为基准位置
SEEK_END     2     把文件尾作为基准位置

如果目标位置在基准位置后则距离用正数表示
如果目标位置在基准位置前则距离用负数表示
距离的绝对值是两个位置之间包含的字节个数。

DAY13 指针强化
用来记录普通类型存储区地址的指针叫
一级指针
二级指针用来记录一级指针的地址
声明二级指针的时候需要写两个*

二级指针前使用**可以表示它捆绑的普通类型存储区
二级指针前使用*可以表示它捆绑的一级指针

如果把指针数组里第一个指针类型存储区的地址
记录到一个二级指针里就可以通过这个二级
指针找到指针数组里的每个指针
这个时候二级指针可以代表整个指针数组
二级指针不可以用来代表二维数组

无类型指针可能实际和一个一级指针捆绑，
这个时候就必须首先强制类型转换
成二级指针然后才能使用
    
二级指针通常作为函数的形式参数使用
被调用函数可以通过二级指针形式参数向
调用函数传递一个地址数据

C语言里函数也有地址
函数名称可以用来代表函数的地址
函数指针用来记录函数地址
函数指针也需要先声明然后才能使用
可以根据函数声明变化得到函数指针声明

函数指针也分类型，不同类型的函数指针
适合与不同类型的函数捆绑

函数指针可以用来调用函数

函数指针可以作为形式参数使用
会作为实际参数使用的函数叫回调函数。
————————————————

DAY 14 C语言的终极：

1.变量 和 常量
2.生命周期和作用域
3.C语言数据处理的各种运算符
4.C语言的各种数据类型
5.指针 与 函数指针。

DAY 15 面向过程编程
它描述的是 函数调用 与 被调用。
终极总结：对 CPU 一系列内存操作流程的抽象。

补充：
左移放大 
右移缩小 

寄存器 绝招
第 n 位清0 var &= ~（1 << n ）
第 n 位置1 var |= 1 << n

程序里 必须不能出现野指针（非空指针）*p p = NULL;

数组名称 是第一元素的地址 
*（arr + num） 
arr + num 就是 + le num * arr元素存储区大小。

C语言的函数都是全局的  

static + 函数 限定 作用域 约定在某个环境内。

内存四区：
代码段    rom 静态区    ram 堆        ram

栈           ram 
————————————————

